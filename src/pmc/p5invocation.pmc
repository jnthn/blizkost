/*
Copyright (C) 2009, Jonathan Worthington and friends
$Id$

=head1 NAME

src/pmc/p5invocation.pmc - Perl 5 method invocation helper

=head1 DESCRIPTION

This PMC is used to map the invocation of a Perl 5 method onto the Parrot
invocation model and calling conventions.

=cut

*/

/* Various Perl 5 headers that we need. */
#undef __attribute__
#undef __attribute__noreturn__
#undef __attribute__deprecated__
#define __attribute__(x) /* */
#include <EXTERN.h>
#include <perl.h>

/* Plus need to know about the interpreter and scalar wrapper. */
#include "pmc_p5interpreter.h"
#include "pmc_p5scalar.h"
#include "pmc_p5namespace.h"
#include "parrot/oplib/ops.h"

/*

=item C<static struct sv *marshall_arg(PARROT_INTERP, PerlInterpreter *my_perl, PMC *arg)>

Takes a PMC and marshalls it into an SV that we can pass to Perl 5.

=cut

*/

PARROT_WARN_UNUSED_RESULT
PARROT_CANNOT_RETURN_NULL
static struct sv *
marshall_arg(PARROT_INTERP, PerlInterpreter *my_perl, PMC *arg) {
    struct sv *result = NULL;

    /* If it's a P5Scalar PMC, then we just fetch the SV from it - trivial
     * round-tripping. */
    if (VTABLE_isa(interp, arg, CONST_STRING(interp, "P5Scalar"))) {
        GETATTR_P5Scalar_sv(interp, arg, result);
    }

    /* XXX At this point, we should probably wrap it up in a tied Perl 5
     * scalar so we can round-trip Parrot objects to. However, that's hard,
     * so for now we cheat on a few special cases and just panic otherwise. */
    else if (VTABLE_isa(interp, arg, CONST_STRING(interp, "Integer"))) {
        result = sv_2mortal(newSViv(VTABLE_get_integer(interp, arg)));
    }
    else if (VTABLE_isa(interp, arg, CONST_STRING(interp, "Float"))) {
        result = sv_2mortal(newSVnv(VTABLE_get_number(interp, arg)));
    }
    else if (VTABLE_isa(interp, arg, CONST_STRING(interp, "String"))) {
        char *c_str = Parrot_str_to_cstring(interp, VTABLE_get_string(interp, arg));
        result = sv_2mortal(newSVpv(c_str, strlen(c_str)));
    }
    else if ( VTABLE_does(interp, arg, CONST_STRING(interp, "array"))) {
        PMC *iter;
        struct av *array = newAV();
        iter = VTABLE_get_iter(interp, arg);
        while (VTABLE_get_bool(interp, iter)) {
             PMC *item = VTABLE_shift_pmc(interp, iter);
             struct sv *marshalled = marshall_arg(interp, my_perl, item);
             av_push( array, marshalled);
        }
        result = newRV_inc(array);

    }
    else if ( VTABLE_does(interp, arg, CONST_STRING(interp, "hash"))) {
        PMC *iter = VTABLE_get_iter(interp, arg);
        struct hv *hash = newHV();
        INTVAL n = VTABLE_elements(interp, arg);
        INTVAL i;
        for(i = 0; i < n; i++) {
            STRING *s = VTABLE_shift_string(interp, iter);
            char *c_str = Parrot_str_to_cstring(interp, s);
            struct sv *val = marshall_arg(interp, my_perl, VTABLE_get_pmc_keyed_str(interp, arg, s));
            hv_store(hash, c_str, strlen(c_str), val, 0);
        }
        result = newRV_inc(hash);
    }
    else {
        Parrot_ex_throw_from_c_args(interp, NULL, 1,
                "Sorry, we do not support marshalling most things to Perl 5 yet.");
    }

    return result;
}


pmclass P5Invocation group blizkost_group dynpmc {
    ATTR PMC       *p5i;
    ATTR struct sv *invocant_sv;
    ATTR PMC       *invocant_ns;
    ATTR STRING    *name;

/*

=item C<void init()>

Set up P5Invocation PMC.

=cut

*/

    VTABLE void init() {
        /* Set up the underlying structure. */
        PMC_data(SELF) = mem_allocate_zeroed_typed(Parrot_P5Invocation_attributes);
        PObj_custom_mark_SET(SELF);
        PObj_custom_destroy_SET(SELF);
    }

/*

=item C<void mark()>

Mark GC-ables.

=cut

*/
    VTABLE void mark() {
        if (PMC_data(SELF)) {
            PMC    *p5i, *invocant_ns;
            STRING *name;
            GETATTR_P5Invocation_p5i(interp, SELF, p5i);
            GETATTR_P5Invocation_invocant_ns(interp, SELF, invocant_ns);
            GETATTR_P5Invocation_name(interp, SELF, name);
            if (p5i)
                Parrot_gc_mark_PObj_alive(interp, (PObj*)p5i);
            if (invocant_ns)
                Parrot_gc_mark_PObj_alive(interp, (PObj*)invocant_ns);
            if (name)
                Parrot_gc_mark_PObj_alive(interp, (PObj*)name);
        }
    }

    VTABLE void destroy() {
        /* XXX TODO. */
    }

/*

=item C<void *invoke(void *next)>

Handles the actual invocation.

=cut

*/
    VTABLE opcode_t *invoke(void *next) {
        STRING          *name;
        char            *c_name;
        struct sv       *invocant_sv;
        PMC             *invocant_ns;
        int              num_returns, num_pos, i;
        PMC             *p5i, *results, *ns, *ns_key, *return_helper;
        PMC             *capture, *named_names, *named_args, *iter;
        PerlInterpreter *my_perl;
        
        /* Get the interpreter, SV and the name. */
        GETATTR_P5Invocation_p5i(interp, SELF, p5i);
        GETATTR_P5Interpreter_my_perl(interp, p5i, my_perl);
        GETATTR_P5Invocation_name(interp, SELF, name);
        c_name = Parrot_str_to_cstring(interp, name);
        GETATTR_P5Invocation_invocant_sv(interp, SELF, invocant_sv);
        GETATTR_P5Invocation_invocant_ns(interp, SELF, invocant_ns);

        /* Grab the parameters; toss the invocant as we already have that. */
        capture     = Parrot_pcc_get_signature(interp, CURRENT_CONTEXT(interp));
        named_names = VTABLE_get_attr_str(interp, capture, string_from_literal(interp, "named"));
        named_args  = Parrot_pmc_new(interp, enum_class_Hash);
        if (!PMC_IS_NULL(named_names)) {
            PMC *iter = VTABLE_get_iter(interp, named_names);
            while (VTABLE_get_bool(interp, iter)) {
                STRING *name = VTABLE_shift_string(interp, iter);
                PMC *value = VTABLE_get_pmc_keyed_str(interp, capture, name);
                VTABLE_set_pmc_keyed(interp, named_args, name, value);
            }
        }
        VTABLE_shift_pmc(interp, capture);

        {
            /* Set up the stack. */
            dSP;
            ENTER;
            SAVETMPS;
            PUSHMARK(SP);
            if (invocant_sv) {
                XPUSHs(sv_2mortal(SvREFCNT_inc(invocant_sv)));
            }
            else {
                STRING *ns_name;
                GETATTR_P5Namespace_ns_name(interp, invocant_ns, ns_name);
                VTABLE_unshift_string(interp, capture, ns_name);
            }

            /* Stick on positional arguments. */
            i = 0;
            num_pos = VTABLE_elements(interp, capture);
            for (i = 0; i < num_pos; i++) {
                PMC *pos_arg = VTABLE_get_pmc_keyed_int(interp, capture, i);
                XPUSHs(marshall_arg(interp, my_perl, pos_arg));
            }

            /* Stick on named arguments (we unbundle them to a string
             * followed by the argument. */
            iter = VTABLE_get_iter(interp, named_args);
            while (VTABLE_get_bool(interp, iter)) {
                STRING *arg_name   = VTABLE_shift_string(interp, iter);
                PMC    *arg_value  = VTABLE_get_pmc_keyed_str(interp, named_args, arg_name);
                char   *c_arg_name = Parrot_str_to_cstring(interp, arg_name);
                XPUSHs(sv_2mortal(newSVpv(c_arg_name, strlen(c_arg_name))));
                XPUSHs(marshall_arg(interp, my_perl, arg_value));
            }

            /* Invoke the methods. */
            PUTBACK;
            num_returns = call_method(c_name, G_ARRAY);
            SPAGAIN;

            /* Build the results PMC array. */
            results = pmc_new(interp, enum_class_ResizablePMCArray);
            for (i = 0; i < num_returns; i++) {
                struct sv *result_sv = POPs;
                PMC *result_pmc = pmc_new(interp, pmc_type(interp, string_from_literal(interp, "P5Scalar")));
                SETATTR_P5Scalar_p5i(interp, result_pmc, SELF);
                SETATTR_P5Scalar_sv(interp, result_pmc, SvREFCNT_inc(result_sv));
                VTABLE_unshift_pmc(interp, results, result_pmc);
            }
            PUTBACK;
            FREETMPS;
            LEAVE;
        }
        mem_sys_free(c_name);

        /* Use the return helper to hand back the result. */
        ns_key = pmc_new(interp, enum_class_ResizableStringArray);
        VTABLE_push_string(interp, ns_key, CONST_STRING(interp, "parrot"));
        VTABLE_push_string(interp, ns_key, CONST_STRING(interp, "Perl5"));
        VTABLE_push_string(interp, ns_key, CONST_STRING(interp, "Compiler"));
        ns = Parrot_get_namespace_keyed(interp, interp->root_namespace, ns_key);
        return_helper = VTABLE_get_pmc_keyed_str(interp, ns, CONST_STRING(interp, "!return_value_helper_arr"));
        return_helper = VTABLE_clone(interp, return_helper);
        VTABLE_setprop(interp, return_helper, CONST_STRING(interp, "$!ret_val"), results);
        return VTABLE_invoke(interp, return_helper, next);
    }
}
