/*
Copyright (C) 2009, Jonathan Worthington and friends

=head1 NAME

src/pmc/p5interpreter.pmc - Embeds a Perl 5 interpreter

=head1 DESCRIPTION

These are the vtable functions for the P5Interpreter class.

=cut

*/

/* Various Perl 5 headers plus XS initialization. */
#undef __attribute__
#undef __attribute__noreturn__
#undef __attribute__deprecated__

#undef __attribute__pure__
#undef __attribute__format__
#undef __attribute__nonnull__
#undef __attribute__warn_unused_result__
#undef __attribute__unused__


#define __attribute__(x) /* */
#include "init_with_xs.h"

/* Need to know a bit about other PMCs. */
#include "pmc_p5scalar.h"

/* Tracking of whether we've initialized or not. */
static int inited = 0;

/*

=head2 Helper functions

=over 4

=back

=head2 Methods

=over 4

=cut

*/

pmclass P5Interpreter group blizkost_group dynpmc {
    ATTR struct interpreter *my_perl;
    ATTR STRING             *source;

/*

=item C<void init()>

Set up P5Interpreter PMC.

=cut

*/

    VTABLE void init() {
        struct interpreter *my_perl;
        char *embedding[] = { "", "-e", "0" };

        /* Set up the underlying structure. */
        PMC_data(SELF) = mem_allocate_zeroed_typed(Parrot_P5Interpreter_attributes);
        PObj_custom_mark_SET(SELF);
        PObj_custom_destroy_SET(SELF);

        /* Inited before? */
        if (!inited) {
            int   fake_argc   = 1;
            char *fake_argv[] = { "" };
            char *fake_env[]  = { NULL };
            PERL_SYS_INIT3(&fake_argc, &fake_argv, &fake_env);
            inited = 1;
        }

        /* Allocate interpreter and stash it in struct. */
        my_perl = perl_alloc();
        perl_construct(my_perl);
        PL_origalen = 1;
        perl_parse(my_perl, xs_init, 3, embedding, NULL);
        PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
        perl_run(my_perl);
        SETATTR_P5Interpreter_my_perl(interp, SELF, my_perl);

        /* We turn on auto-flush to avoid oddness in interactions between
         * IO systems. */
        eval_pv("$| = 1", TRUE);
    }

/*

=item C<void mark()>

Mark source string, if we have one.

=cut

*/
    VTABLE void mark() {
        if (PMC_data(SELF)) {
            STRING *source;
            GETATTR_P5Interpreter_source(interp, SELF, source);
            if (source)
                Parrot_gc_mark_PObj_alive(interp, (PObj*)source);
        }
    }

/*

=item C<void destroy()>

Destructor for the P5Interpreter PMC.

=cut

*/
    VTABLE void destroy() {
        struct interpreter *my_perl;

        /* Destroy interpreter if it's got no more usage. */
        GETATTR_P5Interpreter_my_perl(interp, SELF, my_perl);
        perl_destruct(my_perl);
        perl_free(my_perl);
        
        /* XXX We should only call PERL_SYS_TERM right at the end, not per
         * interpreter destroy. Skip doing it for now at all, but need to
         * work out where to put this. */
        /*PERL_SYS_TERM();*/

        /* Free underlying struct. */
        mem_sys_free(PMC_data(SELF));
        PMC_data(SELF) = NULL;
    }

/*

=item C<void set_string_native(STRING *source)>

Set the source code that we will run.

=cut

*/

    VTABLE void set_string_native(STRING *source) {
        SETATTR_P5Interpreter_source(interp, SELF, source);
    }

/*

=item C<opcode_t *invoke(opcode_t *next)>

Run the Perl 5 code.

=cut

*/

    VTABLE opcode_t *invoke(opcode_t *next) {
        struct interpreter *my_perl;
        PMC    *result, *ns_key, *ns, *return_helper;
        STRING *source;
        char   *c_source;
        SV     *return_code;

        /* Get source into a C string so we can give it to Perl 5.
         * XXX We'd best care about encodings and charset here some day. */
        GETATTR_P5Interpreter_source(interp, SELF, source);
        c_source = Parrot_str_to_cstring(interp, source);

        /* Evaluate it. */
        GETATTR_P5Interpreter_my_perl(interp, SELF, my_perl);
        return_code = eval_pv(c_source, TRUE);
        result = pmc_new(interp, pmc_type(interp, string_from_literal(interp, "P5Scalar")));
        SETATTR_P5Scalar_p5i(interp, result, SELF);
        SETATTR_P5Scalar_sv(interp, result, SvREFCNT_inc(return_code));

        /* Look up return helper. */
        ns_key = pmc_new(interp, enum_class_ResizableStringArray);
        VTABLE_push_string(interp, ns_key, CONST_STRING(interp, "parrot"));
        VTABLE_push_string(interp, ns_key, CONST_STRING(interp, "Perl5"));
        VTABLE_push_string(interp, ns_key, CONST_STRING(interp, "Compiler"));
        ns = Parrot_get_namespace_keyed(interp, interp->root_namespace, ns_key);
        return_helper = VTABLE_get_pmc_keyed_str(interp, ns, CONST_STRING(interp, "!return_value_helper"));

        /* Clone it and use property to attach return value (the helper just
         * handles PCC for us). */
        return_helper = VTABLE_clone(interp, return_helper);
        VTABLE_setprop(interp, return_helper, CONST_STRING(interp, "$!ret_val"), result);
        next = VTABLE_invoke(interp, return_helper, next);

        /* Free memory associated with the string, and we're done. */
        mem_sys_free(c_source);
        return next;
    }
}

/*

=back

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
